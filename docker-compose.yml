services:

  # ── Game server ───────────────────────────────────────────────────────────
  # Thin container running the ORMOD: Directive dedicated server binary.
  #
  # GAME_BINARY_PATH  — host path to the game binary directory (bind-mounted
  #                     into the container). Default: ./docker/game-binary
  #                     Dedi-box layout: set to ../server in .env
  #
  # GAME_BINARY_NAME  — filename of the server executable inside that directory.
  #                     Default: ORMODDirective
  #                     Change if your binary has a different name (e.g. dedicated).
  #
  # SAVES_PATH        — host path for save data / server config files.
  #                     Default: named volume `game-saves` (Docker managed).
  #                     Dedi-box layout: set to ../configs in .env
  #                     When set to a host path, files are directly accessible
  #                     on the host filesystem. Ensure the directory is writable
  #                     by UID 1000 (steam) before starting.
  #
  # GAME_HOST         — host IP to bind the game ports to.
  #                     Default: 0.0.0.0 (all interfaces).
  #                     Set to a specific IP to bind game traffic to one NIC,
  #                     e.g. a public interface while the dashboard is LAN-only.
  #
  # GAME_PORT /       — UDP ports the game listens on (set in serversettings.json).
  # QUERY_PORT /        These values tell Docker which ports to forward from the
  # KCP_PORT             host. Keep them in sync with serversettings.json.
  #                     KCP_PORT is the game traffic port (Mirror/KCP networking).
  #
  # Future: when the game ships on Steam, swap Dockerfile.gameserver to
  # SteamCMD and remove the GAME_BINARY_PATH volume entry below.
  ormod-game:
    build:
      context: .
      dockerfile: docker/Dockerfile.gameserver
    container_name: ${GAME_CONTAINER_NAME:-ormod-game}
    restart: unless-stopped
    environment:
      SERVER_NAME: ${SERVER_NAME:-MyOrmodServer}
      GAME_BINARY_NAME: ${GAME_BINARY_NAME:-ORMODDirective}
    volumes:
      - ${GAME_BINARY_PATH:-./docker/game-binary}:/game                      # game binary directory
      - ${SAVES_PATH:-game-saves}:/saves                                     # save data / server configs
    ports:
      # Host:container ports use the same value — the game's actual port is set
      # in serversettings.json; GAME_PORT / QUERY_PORT just document that value
      # and tell Docker which ports to forward.
      - "${GAME_HOST:-0.0.0.0}:${GAME_PORT:-27015}:${GAME_PORT:-27015}/udp"
      - "${GAME_HOST:-0.0.0.0}:${QUERY_PORT:-27016}:${QUERY_PORT:-27016}/udp"
      - "${GAME_HOST:-0.0.0.0}:${KCP_PORT:-7777}:${KCP_PORT:-7777}/udp"
    stdin_open: true   # Keep stdin pipe open so the dashboard can write to it
    tty: true          # Required: game reads console commands from a PTY, not a plain
                       # pipe. With tty: true Docker streams raw bytes for logs (no
                       # 8-byte frame headers) — docker-manager handles this correctly.

  # ── Dashboard (API + frontend) ────────────────────────────────────────────
  # Single container: Fastify REST/WebSocket API + built React UI.
  # The Docker socket grants control over the game container (start/stop/exec).
  # Save files are shared via the same volume/path as the game container.
  #
  # PUBLIC_URL    — full URL clients use to reach the dashboard.
  #                 Required for any non-localhost deployment.
  #                 Examples:
  #                   LAN/WAN:          http://192.168.1.100:3000
  #                   Cloudflare TLS:   https://rcon.example.com
  #                 Leave empty for localhost-only testing.
  #
  # API_HOST      — IP address Fastify binds to on the host.
  #                 Default: 0.0.0.0 (all interfaces).
  #                 Set to a specific IP to restrict access, e.g. 10.0.0.1
  #                 With network_mode: host, this directly controls which
  #                 interface the dashboard listens on. Combined with UFW,
  #                 this gives full firewall control (Docker bridge networking
  #                 bypasses UFW — host mode does not).
  #
  # API_PORT      — port Fastify listens on (default: 3000).
  #                 With network_mode: host, this is the actual host port.
  ormod-dashboard:
    build:
      context: .
      dockerfile: docker/Dockerfile.dashboard
    container_name: ormod-dashboard
    restart: unless-stopped
    network_mode: host
    depends_on:
      - ormod-game
    environment:
      DATABASE_URL: file:/data/ormod-rcon.db
      SAVE_BASE_PATH: /saves
      BACKUP_PATH: /backups
      BETTER_AUTH_SECRET: ${BETTER_AUTH_SECRET}
      API_HOST: ${API_HOST:-0.0.0.0}
      API_PORT: ${API_PORT:-3000}
      PUBLIC_URL: ${PUBLIC_URL:-}
      STATIC_PATH: /app/apps/web/dist
      GAME_CONTAINER_NAME: ${GAME_CONTAINER_NAME:-ormod-game}
      # TLS — uncomment and set paths to enable native HTTPS
      # TLS_CERT_PATH: ${TLS_CERT_PATH:-}
      # TLS_KEY_PATH: ${TLS_KEY_PATH:-}
    volumes:
      - ./data:/data                                                         # SQLite database
      - ${SAVES_PATH:-game-saves}:/saves                                     # Shared save files (read-write)
      - ./backups:/backups                                                   # Pre-wipe backup archives
      - /var/run/docker.sock:/var/run/docker.sock                           # Docker API (process mgmt)
      - ./certs:/certs:ro                                                    # TLS certs (optional)

# Named volume used when SAVES_PATH is not set.
# Docker Compose treats strings starting with ./ ../ or / as bind mounts;
# everything else (like the default "game-saves") is a named volume.
volumes:
  game-saves:
